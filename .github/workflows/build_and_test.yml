name: Build & Test

on:
  push:
    branches:
      - publish-builds-as-github-packages
  # push:
  #   branches:
  #     - master
  #     - major
  #     - minor
  #     - parallel-e2e
  # pull_request:
  #   branches:
  #     - master
  #     - major
  #     - minor
env:
  CI: true
  node: 20.x
jobs:
  # build:
  #   name: build
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #     packages: write
  #     actions: read
  #   steps:
  #   - uses: actions/checkout@v3
  #   - name: Use Node.js ${{ env.node }}
  #     uses: actions/setup-node@v3
  #     with:
  #       node-version: ${{ env.node }}
  #       registry-url: 'https://npm.pkg.github.com'
  #       scope: '@Invocure'

  #   - name: Install jq
  #     run: sudo apt-get install -y jq

  #   - name: npm install
  #     run: |
  #       npm install
  #       npm install --os=linux --cpu=x64 sharp

  #   - name: Build
  #     run: npm run build

  #   - name: Current directory
  #     run: pwd

  #   - name: Show list
  #     run: ls -la

  #   - name: Update package.json
  #     run: |
  #       NEW_REGISTRY="https://npm.pkg.github.com"
  #       NEW_ACCESS="restricted"
  #       NEW_REPO_URL="git+https://github.com/Invocure/vendure-fork.git"
  #       REPO_TYPE="git"
  #       NEW_NAME="@Invocure/email-plugin"

  #       # Use jq to update the package.json fields
  #       jq --arg registry "$NEW_REGISTRY" --arg access "$NEW_ACCESS" '.publishConfig = {registry: $registry, access: $access}' ./packages/email-plugin/package.json > package.tmp.json && mv package.tmp.json ./packages/email-plugin/package.json
  #       jq --arg url "$NEW_REPO_URL" --arg type "$REPO_TYPE" '.repository = {type: $type, url: $url}' ./packages/email-plugin/package.json > package.tmp.json && mv package.tmp.json ./packages/email-plugin/package.json
  #       jq --arg name "$NEW_NAME" '.name = $name' ./packages/email-plugin/package.json > package.tmp.json && mv package.tmp.json ./packages/email-plugin/package.json

  #       echo "Updated package.json"

  #   - name: publish
  #     run: npm publish --access restricted
  #     env:
  #       NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build_and_publish_email_plugin:
    name: email-plugin
    uses: ./.github/workflows/build_publish_plugin.yaml
    with:
      plugin-name: 'email-plugin'
      node-version: '20.x'
    permissions:
      contents: read
      packages: write
      actions: read

  # build_and_publish_core_plugin:
  #   name: core-plugin
  #   uses: ./.github/workflows/build_publish_plugin.yaml
  #   with:
  #     plugin-name: 'core'
  #     node-version: '20.x'
  #   permissions:
  #     contents: read
  #     packages: write
  #     actions: read

  unit-tests:
    name: unit tests
    runs-on: ubuntu-latest
    if: false # This will prevent the job from running
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ env.node }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.node }}
      - name: npm install
        run: |
          npm install
          npm install --os=linux --cpu=x64 sharp
      - name: Build
        run: lerna run ci
      - name: Unit tests
        run: npm run test
  e2e-tests:
    name: e2e tests
    runs-on: ubuntu-latest
    if: false # This will prevent the job from running
    services:
      mariadb:
        image: bitnami/mariadb:10.3
        env:
          ALLOW_EMPTY_PASSWORD: yes
        ports:
          - 3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
      mysql:
        image: bitnami/mysql:8.0
        env:
          ALLOW_EMPTY_PASSWORD: yes
          MYSQL_AUTHENTICATION_PLUGIN: mysql_native_password
        ports:
          - 3306
        options: --health-cmd="mysqladmin ping --silent" --health-interval=10s --health-timeout=20s --health-retries=10
      postgres:
        image: postgres:12
        env:
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: secret
        ports:
          - 5432
        options: --health-cmd=pg_isready --health-interval=10s --health-timeout=5s --health-retries=3
      elastic:
        image: docker.elastic.co/elasticsearch/elasticsearch:7.1.1
        env:
          discovery.type: single-node
          bootstrap.memory_lock: true
          ES_JAVA_OPTS: -Xms512m -Xmx512m
          # Elasticsearch will force read-only mode when total available disk space is less than 5%. Since we will
          # be running on a shared Azure instance with 84GB SSD, we easily go below 5% available even when there are still
          # > 3GB free. So we set this value to an absolute one rather than a percentage to prevent all the Elasticsearch
          # e2e tests from failing.
          cluster.routing.allocation.disk.watermark.low: 500mb
          cluster.routing.allocation.disk.watermark.high: 200mb
          cluster.routing.allocation.disk.watermark.flood_stage: 100mb
        ports:
          - 9200
        options: --health-cmd="curl --silent --fail localhost:9200/_cluster/health" --health-interval=10s --health-timeout=5s --health-retries=3
    strategy:
      fail-fast: false
      matrix:
        db: [sqljs, mariadb, mysql, postgres]
    steps:
      - uses: actions/checkout@v3
      - name: Use Node.js ${{ env.node }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.node }}
      - name: npm install
        run: |
          npm install
          npm install --os=linux --cpu=x64 sharp
      - name: Build
        run: lerna run ci
      - name: df
        run: |
          df -h
          docker system df
      - name: e2e tests
        env:
          E2E_MYSQL_PORT: ${{ job.services.mysql.ports['3306'] }}
          E2E_MARIADB_PORT: ${{ job.services.mariadb.ports['3306'] }}
          E2E_POSTGRES_PORT: ${{ job.services.postgres.ports['5432'] }}
          E2E_ELASTIC_PORT: ${{ job.services.elastic.ports['9200'] }}
          DB: ${{ matrix.db }}
        run: npm run e2e
